#!/usr/bin/env bash

set -ex

export TMP_HOME=${PWD}
export GOROOT=/usr/local/go
export PATH=${GOROOT}/bin:${PATH}

# Update to concourse 2.7.3 and garden-runc 1.4.0 caused inigo to fail since
# resolv.conf is now bind-mounted in. Removing the apt-get install, two inigo
# tests were failing because they were unable to resolve DNS names.
echo "nameserver 8.8.8.8" >> /etc/resolv.conf

# Adds the cell announced urls to the /etc/hosts file. We cannot use consul
# reliably since there could be multiple consuls running on multiple ginkgo
# nodes. Adding all of them to the /etc/resolv.conf will lead potential to
# cross talking across the different tests.
function setup_localhost_hosts() {
  local hosts_file
  hosts_file=/etc/hosts
  for ginkgoNode in {1..30}; do
      for repN in {0..30}; do
          echo "127.0.0.1 the-cell-id-${ginkgoNode}-${repN}.cell.service.cf.internal" >> "${hosts_file}"
      done
  done

  # The following rep cell ids are used in the evacuation test :(
  echo "127.0.0.1 cell-a.cell.service.cf.internal" >> "${hosts_file}"
  echo "127.0.0.1 cell-b.cell.service.cf.internal" >> "${hosts_file}"
  echo "127.0.0.1 file-server.service.cf.internal" >> "${hosts_file}"
}

build_gardenrunc () {
  echo "Building garden-runc"
  export GARDEN_GOPATH=$1

  pushd ${GARDEN_GOPATH}
    export GOPATH=${PWD}
    export PATH=${GOPATH}/bin:${PATH}
    export GARDEN_BINPATH=${PWD}/bin/

    mkdir -p $GOPATH/bin
    NSTAR_PATH=src/code.cloudfoundry.org/guardian/rundmc/nstar

    gcc -static -o $GOPATH/bin/init $GOPATH/src/code.cloudfoundry.org/guardian/cmd/init/init.c
    go install code.cloudfoundry.org/guardian/cmd/dadoo/
    go install code.cloudfoundry.org/grootfs/store/filesystems/overlayxfs/tardis

    pushd src/github.com/opencontainers/runc
      PKG_CONFIG_PATH=/usr/local/lib/pkgconfig GOPATH=${PWD}/Godeps/_workspace:${GOPATH} BUILDTAGS="seccomp" make static
      mv runc ${GARDEN_BINPATH}
    popd

    pushd $NSTAR_PATH
      make && cp nstar ${GARDEN_BINPATH}
    popd
  popd
}

# source: cloudfoundry/grootfs/ci/scripts/test/utils.sh
mount_btrfs() {
  # Configure cgroup
  mount -tcgroup -odevices cgroup:devices /sys/fs/cgroup
  devices_mount_info=$(cat /proc/self/cgroup | grep devices)
  devices_subdir=$(echo $devices_mount_info | cut -d: -f3)
  echo 'b 7:* rwm' > /sys/fs/cgroup/devices.allow
  echo 'b 7:* rwm' > /sys/fs/cgroup${devices_subdir}/devices.allow

  # Setup loop devices
  for i in {0..256}
  do
    mknod -m777 /dev/loop$i b 7 $i
  done

  # Make BTRFS volume
  truncate -s 8G /btrfs_volume
  mkfs.btrfs /btrfs_volume

  # Mount BTRFS
  mkdir /mnt/btrfs
  mount -t btrfs -o user_subvol_rm_allowed,rw /btrfs_volume /mnt/btrfs
  chmod 777 -R /mnt/btrfs
  btrfs quota enable /mnt/btrfs
}

build_grootfs () {
  echo "Building grootfs..."
  export GROOTFS_GOPATH=${PWD}/garden-runc-release
  export GROOTFS_BINPATH=${GROOTFS_GOPATH}/bin
  mkdir -p ${GROOTFS_BINPATH}

  pushd ${GROOTFS_GOPATH}/src/code.cloudfoundry.org/grootfs
    export GOPATH=${GROOTFS_GOPATH}
    export PATH=${GOPATH}/bin:${PATH}

    # Set up btrfs volume and loopback devices in environment
    mount_btrfs
    umount /sys/fs/cgroup || true

    make

    mv grootfs ${GROOTFS_GOPATH}/bin/
    mv drax /usr/local/bin
    chown root:root /usr/local/bin/drax
    chmod u+s /usr/local/bin/drax

    echo "grootfs installed."

    groupadd iamgroot -g 4294967294
    useradd iamgroot -u 4294967294 -g 4294967294
    echo "iamgroot:1:4294967293" > /etc/subuid
    echo "iamgroot:1:4294967293" > /etc/subgid
  popd
}

set_garden_rootfs () {
  # use the 1.29 version of tar that's installed in the inigo-ci docker image
  ln -sf /usr/local/bin/tar "${GARDEN_BINPATH}"

  tar cpf /tmp/rootfs.tar -C /opt/inigo/rootfs .
  export GARDEN_ROOTFS=/tmp/rootfs.tar
}

setup_gopath() {
  pushd $1

  bosh sync-blobs


  if [ -d "$1/blobs/proxy" ]; then
    mkdir /tmp/envoy
    tar -C /tmp/envoy -xf blobs/proxy/envoy*.tgz
    export ENVOY_PATH=/tmp/envoy
    chmod 777 $ENVOY_PATH
  fi

  export GOPATH_ROOT=$PWD

  export GOPATH=${GOPATH_ROOT}
  export PATH=${GOPATH_ROOT}/bin:${PATH}

  # install application dependencies
  echo "Installing go dependencies ..."
  for package in github.com/apcera/gnatsd; do
    go install $package
  done

  go install github.com/onsi/ginkgo/ginkgo
  popd
}

setup_database() {
  ca_file="${GOPATH_ROOT}/src/code.cloudfoundry.org/inigo/fixtures/certs/sql-certs/server-ca.crt"
  cert_file="${GOPATH_ROOT}/src/code.cloudfoundry.org/inigo/fixtures/certs/sql-certs/server.crt"
  key_file="${GOPATH_ROOT}/src/code.cloudfoundry.org/inigo/fixtures/certs/sql-certs/server.key"

  chmod 0600 "$ca_file"
  chmod 0600 "$cert_file"
  chmod 0600 "$key_file"

  if [ "${SQL_FLAVOR}" = "mysql" ]; then
    source ${GOPATH_ROOT}/scripts/ci/initialize_mysql.sh

    sed -i 's/#max_connections.*= 100/max_connections = 2000/g' /etc/mysql/mysql.conf.d/mysqld.cnf

    chown mysql:mysql "$ca_file"
    chown mysql:mysql "$cert_file"
    chown mysql:mysql "$key_file"

    sed -i "s%# ssl-cert=/etc/mysql/server-cert.pem%ssl-cert=$cert_file%g" /etc/mysql/mysql.conf.d/mysqld.cnf
    sed -i "s%# ssl-key=/etc/mysql/server-key.pem%ssl-key=$key_file%g" /etc/mysql/mysql.conf.d/mysqld.cnf
    sed -i "s%# ssl-ca=/etc/mysql/cacert.pem%ssl-ca=$ca_file%g" /etc/mysql/mysql.conf.d/mysqld.cnf
    initialize_mysql
  else
    sed -i 's/max_connections = 100/max_connections = 2000/g' /etc/postgresql/9.4/main/postgresql.conf

    chown postgres:postgres "$ca_file"
    chown postgres:postgres "$cert_file"
    chown postgres:postgres "$key_file"

    sed -i 's/ssl = false/ssl = true/g' /etc/postgresql/9.4/main/postgresql.conf
    sed -i "s%ssl_cert_file = '/etc/ssl/certs/ssl-cert-snakeoil.pem'%ssl_cert_file = '$cert_file'%g" /etc/postgresql/9.4/main/postgresql.conf
    sed -i "s%ssl_key_file = '/etc/ssl/private/ssl-cert-snakeoil.key'%ssl_key_file = '$key_file'%g" /etc/postgresql/9.4/main/postgresql.conf
    sed -i "s%#ssl_ca_file = ''%ssl_ca_file = '$ca_file'%g" /etc/postgresql/9.4/main/postgresql.conf

    service postgresql start
  fi
}

setup_localhost_hosts

build_gardenrunc $PWD/garden-runc-release

build_grootfs

# setup v0 env vars for dusts-v2
if [ -d $PWD/diego-release-v0 ]; then
    setup_gopath $PWD/diego-release-v0
    export AUCTIONEER_GOPATH_V0=${GOPATH_ROOT}
    export BBS_GOPATH_V0=${GOPATH_ROOT}
    export HEALTHCHECK_GOPATH_V0=${GOPATH_ROOT}
    export REP_GOPATH_V0=${GOPATH_ROOT}
    export ROUTE_EMITTER_GOPATH_V0=${GOPATH_ROOT}
    export SSHD_GOPATH_V0=${GOPATH_ROOT}
    export SSH_PROXY_GOPATH_V0=${GOPATH_ROOT}
fi

export ROUTER_GOPATH="$PWD/routing-release"
export ROUTING_API_GOPATH=${ROUTER_GOPATH}

setup_gopath $PWD/diego-release
set_garden_rootfs

export APP_LIFECYCLE_GOPATH=${GOPATH_ROOT}
export AUCTIONEER_GOPATH=${GOPATH_ROOT}
export BBS_GOPATH=${GOPATH_ROOT}
export FILE_SERVER_GOPATH=${GOPATH_ROOT}
export HEALTHCHECK_GOPATH=${GOPATH_ROOT}
export LOCKET_GOPATH=${GOPATH_ROOT}
export REP_GOPATH=${GOPATH_ROOT}
export ROUTE_EMITTER_GOPATH=${GOPATH_ROOT}
export SSHD_GOPATH=${GOPATH_ROOT}
export SSH_PROXY_GOPATH=${GOPATH_ROOT}

# used for routing to apps; same logic that Garden uses.
EXTERNAL_ADDRESS=$(ip route get 8.8.8.8 | sed 's/.*src\s\(.*\)\s/\1/;tx;d;:x')
export EXTERNAL_ADDRESS

setup_database

# display ginkgo dots properly
export LESSCHARSET=utf-8

export GARDEN_GRAPH_PATH=/tmp/aufs_mount
mkdir -p "${GARDEN_GRAPH_PATH}"
mount -t tmpfs tmpfs "${GARDEN_GRAPH_PATH}"

# workaround until Concourse's garden sets this up for us
if ! grep -qs '/sys' /proc/mounts; then
  mount -t sysfs sysfs /sys
fi

# shellcheck source=/dev/null
source "${GARDEN_GOPATH}/ci/scripts/device-control"
permit_device_control
create_loop_devices 256

set +ex
